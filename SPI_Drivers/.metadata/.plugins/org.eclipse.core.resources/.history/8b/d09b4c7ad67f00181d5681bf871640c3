/*
 * hal_spi_driver.c
 *
 */
#include "hal_spi_driver.h"


void hal_spi_init(spi_handle *spi_hndlr){
	/*Configuring:
	 * CPHA and CPOL
	 * SPI DATA SIZE
	 *
	 */
}

/******************************************************************************/
/*                                                                            */
/*                      Helper functions                                 */
/*                                                                            */
/******************************************************************************/
/**
 * Configures master or slave mode
 */
void hal_spi_config_device_mode(SPI_TypeDef *SPIx, uint32_t master){
	if (master){
		SPIx->CR1 |= SPI_CR1_MSTR;
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_MSTR;
	}
}

void hal_spi_config_phase_polarity(SPI_TypeDef *SPIx, uint32_t phase, uint32_t polarity){
	if (phase){
		SPIx->CR1 |= SPI_CR1_CPHA;
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_CPHA;
	}

	if (polarity){
		SPIx->CR1 |= SPI_CR1_CPOL;
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_CPOL;
	}
}

// BY DEFAULT, SPI SENTS 8-bit data with MSB first
void hal_spi_config_data_size_direction(SPI_TypeDef *SPIx, uint32_t datasize_16, uint32_t lsb_first){
	if (datasize_16){
		SPIx->CR1 |= SPI_CR1_DFF;	//16 bit
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_DFF;	//8 bit
	}

	if (lsb_first){
		SPIx->CR1 |= SPI_CR1_LSB_FIRST;	//send out LSB first
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_LSB_FIRST;	//send out MSB first
	}
}

//Software/hardware slave management (SSM)
void hal_spi_config_nss_master(SPI_TypeDef *SPIx, uint32_t ssm_enable){
	if (ssm_enable){
		SPIx->CR1 |= SPI_CR1_SSM;		//software management
		SPIx->CR1 |= SPI_CR1_SSI;		//NSS pin takes on SSI's value == 1
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_SSM;		//hardware management

	}
}

void hal_spi_config_nss_slave(SPI_TypeDef *SPIx, uint32_t ssm_enable){
	if (ssm_enable){
		SPIx->CR1 |= SPI_CR1_SSM;
	}
	else{
		SPIx->CR1 &= ~SPI_CR1_SSM;
	}
}

//Enable SPI
void hal_spi_enable(SPI_TypeDef *SPIx){
	if (!(SPIx->CR1 & SPI_EN)){		//if SPI isn't enabled
		SPIx->CR1 |= SPI_EN;
	}
}
//Disable SPI
void hal_spi_disable(SPI_TypeDef *SPIx){
	SPIx->CR1 &= ~SPI_EN;
}

//INTERRUPT
void hal_spi_enable_txe_interrupt(SPI_TypeDef *SPIx){
	SPIx->CR2 |= SPI_CR2_TXEIE;	//enabling TX buffer empty interrupt
}

void hal_spi_enable_rxne_interrupt(SPI_TypeDef *SPIx){
	SPIx->CR2 |= SPI_CR2_RXNEIE;
}

/******************************************************************************/
/*                                                                            */
/*                      API functions                                 */
/*                                                                            */
/******************************************************************************/
/* --- MASTER ---- */
//API used for master data transmission
void hal_spi_master_tx(spi_handle_t *spi_handle, uint8_t *tx_buffer, uint32_t length){
	spi_handle->txBuffer = tx_buffer;
	spi_handle->TX_tranfer_size = length;

	spi_handle->state = HAL_SPI_STATE_BUSY_TX; //setting the state for transmitting data
	hal_spi_enable(spi_handle->Instance);	//enabling SPI communication

	hal_spi_enable_txe_interrupt(spi_handle->Instance);	//enabling TX interrupt for empty TX Buffer

}
//API used for master data reception
void hal_spi_master_rx(spi_handle_t *spi_handle, uint8_t *rx_buffer, uint32_t length){
	int32_t val;

	/* dummy TX */
	spi_handle->txBuffer = rx_buffer;
	spi_handle->TX_tranfer_size = length;

	/* Address of RX Buffer is stored*/
	spi_handle->rxBuffer = rx_buffer;
	spi_handle->RX_tranfer_size = length;

	/*Driver is busy in RX */
	spi_handle->state = HAL_SPI_STATE_BUSY_RX;

	/* Enabling SPI Interrupt */
	hal_spi_enable(spi_handle->Instance);

	/* reading DR to see if it's empty */
	val = spi_handle->Instance->DR;

	/* Enabling both TXE and RXNE Interrupt */

}

/* --- SLAVE ---- */
// API for SLAVE data transmission
void hal_spi_slave_tx(spi_handle_t *spi_handle, uint8_t *tx_buffer, uint32_t length){

	/* Address of RX Buffer is stored */
	spi_handle->txBuffer = tx_buffer;
	spi_handle->TX_tranfer_size = length;

	/* Dummy RX */
	spi_handle->rxBuffer = tx_buffer;
	spi_handle->RX_tranfer_size = length;

	/*Driver is busy in TX */
	spi_handle->state = HAL_SPI_STATE_BUSY_TX;

	/* Enabling SPI Interrupt */
	hal_spi_enable(spi_handle->Instance);

	/* Enabling both TXE and RXNE Interrupt */
	hal_spi_enable_rxne_interrupt(spi_handle->Instance);
	hal_spi_enable_txe_interrupt(spi_handle->Instance);
}





